/**
 * @file base model 基础模块
 * @author Yourtion Guo <yourtion@gmail.com>
 */
import { Delete, Insert, MysqlInsert, QueryBuilder, Select, Update } from "squel";
import * as Squel from "squel";
export declare const squel: Squel.MysqlSquel;
export { Delete, Insert, MysqlInsert, Select, Update };
export interface IKVObject<T = any> {
    [key: string]: T;
}
export declare type IConditions = IKVObject<string | string[]>;
export declare type IPrimary = string | number;
export interface IPageParams {
    limit?: number;
    offset?: number;
    order?: string;
    asc?: boolean;
}
export interface IPageResult<T> {
    count: number;
    list: T[];
}
export interface IConnection {
    getConnectionAsync: () => Promise<IConnection>;
    release(options?: any): Promise<void>;
    beginTransactionAsync(options?: any): Promise<void>;
    queryAsync: (options: string, values?: any) => Promise<any>;
    debug?: (sql: any) => any;
    commitAsync(options?: any): Promise<void>;
    rollbackAsync(options?: any): Promise<void>;
}
export interface IBaseOptions {
    /** 表前缀 */
    prefix?: string;
    /** 主键名（默认为 id ） */
    primaryKey?: string;
    /** 默认 query 的列 */
    fields?: string[];
    /** 默认排序字段 */
    order?: string;
    /** 默认asc */
    asc?: boolean;
}
export default abstract class EBase<T> {
    table: string;
    primaryKey: string;
    fields: string[];
    parseWhere: (sql: Select, conditions: IKVObject<string | string[]>) => void;
    protected connect: IConnection;
    private order?;
    private asc;
    private log;
    constructor(table: string, connect: IConnection, options?: IBaseOptions);
    /**
     * 输出 SQL Debug
     */
    abstract debugInfo<U = string>(name?: string): (info: U) => U;
    /**
     * 查询方法（内部查询尽可能调用这个，会打印Log）
     */
    query(sql: QueryBuilder | string, connection?: IConnection): Promise<any>;
    /**
     * 错误处理方法
     */
    abstract errorHandler(err: any): void;
    _count(conditions?: IConditions): Select;
    countRaw(connect: IConnection, conditions?: IConditions): Promise<number>;
    /**
     * 计算数据表 count
     */
    count(conditions?: IConditions): Promise<number>;
    _getByPrimary(primary: IPrimary, fields: string[]): Select;
    getByPrimaryRaw(connect: IConnection, primary: string, fields?: string[]): Promise<T>;
    /**
     * 根据主键获取数据
     */
    getByPrimary(primary: string, fields?: string[]): Promise<T>;
    _getOneByField(object?: IKVObject, fields?: string[]): Select;
    getOneByFieldRaw(connect: IConnection, object?: IKVObject, fields?: string[]): Promise<T>;
    /**
     * 根据查询条件获取一条记录
     */
    getOneByField(object?: IKVObject, fields?: string[]): Promise<T>;
    _deleteByPrimary(primary: IPrimary, limit?: number): Delete;
    deleteByPrimaryRaw(connect: IConnection, primary: IPrimary, limit?: number): Promise<number>;
    /**
     * 根据主键删除数据
     */
    deleteByPrimary(primary: IPrimary, limit?: number): Promise<number>;
    _deleteByField(conditions: IConditions, limit?: number): Delete;
    deleteByFieldRaw(connect: IConnection, conditions: IConditions, limit?: number): Promise<number>;
    /**
     * 根据查询条件删除数据
     */
    deleteByField(conditions: IConditions, limit?: number): Promise<number>;
    /**
     * 根据查询条件获取记录
     */
    getByField(conditions?: IConditions, fields?: string[]): Promise<T[]>;
    _insert(object?: IKVObject): MysqlInsert;
    insertRaw(connect: IConnection, object?: IKVObject): Promise<any>;
    /**
     * 插入一条数据
     */
    insert(object?: IKVObject): Promise<any>;
    _batchInsert(array: IKVObject[]): MysqlInsert;
    /**
     * 批量插入数据
     */
    batchInsert(array: IKVObject[]): Promise<any>;
    _updateByField(conditions: IConditions, objects: IKVObject, raw?: boolean): Update;
    updateByFieldRaw(connect: IConnection, conditions: IConditions, objects: IKVObject, raw?: boolean): Promise<number>;
    /**
     * 根据查询条件更新记录
     */
    updateByField(conditions: IConditions, objects: IKVObject, raw?: boolean): Promise<number>;
    /**
     * 根据主键更新记录
     */
    updateByPrimary(primary: IPrimary, objects: IKVObject, raw?: boolean): Promise<number>;
    _createOrUpdate(objects: IKVObject, update?: string[]): MysqlInsert;
    /**
     * 创建一条记录，如果存在就更新
     */
    createOrUpdate(objects: IKVObject, update?: string[]): Promise<any>;
    _incrFields(primary: IPrimary, fields: string[], num?: number): Update;
    incrFieldsRaw(connect: IConnection, primary: IPrimary, fields: string[], num?: number): Promise<number>;
    /**
     * 根据主键对数据列执行加一操作
     */
    incrFields(primary: IPrimary, fields: string[], num?: number): Promise<number>;
    _list(conditions?: IConditions, fields?: string[], limit?: number, offset?: number, order?: string | undefined, asc?: boolean): Select;
    listRaw(connect: IConnection, conditions?: {}, fields?: string[], ...args: any[]): Promise<T[]>;
    /**
     * 根据条件获取列表
     */
    list(conditions: IConditions, fields?: string[], pages?: IPageParams): Promise<T[]>;
    /**
     * 根据条件获取列表
     */
    list(conditions: IConditions, fields?: string[], limit?: number, offset?: number, order?: string, asc?: boolean): Promise<T[]>;
    _search(keyword: string, search: string[], fields?: string[], limit?: number, offset?: number, order?: string | undefined, asc?: boolean): Select;
    /**
     * 根据关键词进行搜索
     */
    search(keyword: string, search: string[], fields?: string[], pages?: IPageParams): Promise<T[]>;
    /**
     * 根据关键词进行搜索
     */
    search(keyword: string, search: string[], fields?: string[], limit?: number, offset?: number, order?: string, asc?: boolean): Promise<T[]>;
    /**
     * 根据条件获取分页内容（比列表多出总数计算）
     */
    page(conditions: IConditions, fields?: string[], limit?: number, offset?: number, order?: string, asc?: boolean): Promise<IPageResult<T>>;
    /**
     * 根据条件获取分页内容（比列表多出总数计算）
     */
    page(conditions: IConditions, fields?: string[], pages?: IPageParams): Promise<IPageResult<T>>;
    /**
     * 执行事务（通过传入方法）
     */
    transactions(name: string, func: (conn: any) => any): () => Promise<any>;
    /**
     * 执行事务（通过传人SQL语句数组）
     */
    transactionSQLs(sqls: string[]): () => Promise<void>;
}
